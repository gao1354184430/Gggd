#!/bin/bash
#远端文件储存地址
Github="https://ghproxy.net/https://raw.githubusercontent.com/gao1354184430/Gggd/master/test/test6"
GostService="https://ghproxy.net/https://raw.githubusercontent.com/KANIKIG/Multi-EasyGost/master"
cndownload="https://ghproxy.net/https://raw.githubusercontent.com/gao1354184430/Gggd/master/test/test5"
#gost指定版本
ct_new_ver="2.11.1"
#测试与GitHub连通性
rm -rf /root/.test.txt
curl -s $Github/test > /root/.test.txt
github_test=`sed -n '1p' /root/.test.txt`
rm -rf /root/.test.txt /root/.crontab.txt
#颜色文字
Green_font_prefix="\033[32m" && Red_font_prefix="\033[31m" && Green_background_prefix="\033[42;37m" && Red_background_prefix="\033[41;37m" && Font_color_suffix="\033[0m"
Info="${Green_font_prefix}[信息]${Font_color_suffix}"
Error="${Red_font_prefix}[错误]${Font_color_suffix}"
Tip="${Green_font_prefix}[注意]${Font_color_suffix}"
#开放防火墙
function install_iptables(){
systemctl stop firewalld
systemctl mask firewalld
yum install -y iptables
yum install iptables-services -y
iptables -F
iptables -P INPUT ACCEPT
iptables -X
service iptables save
}
function install_vnets(){
	yum -y install zip unzip vim
    mkdir /usr/local/vnet
    cd /usr/local/vnet
    wget -N --no-check-certificate "https://www.isyunyi.com/download/linux/tunnel.zip"
    unzip tunnel.zip 
    rm -f /usr/local/vnet/tunnel.zip
    rm -f /usr/local/vnet/client
    echo '#!/bin/bash
sleep 0.5
cd /usr/local/vnet
./server' >/usr/local/vnet/server.sh  
	rm -rf /usr/local/vnet/server.conf
	wget -N --no-check-certificate $Github/node/$diQu/server.conf -O /usr/local/vnet/server.conf
    chmod +x /usr/local/vnet/server /usr/local/vnet/server.sh /usr/local/vnet/server.conf
	echo '
[Unit]
Description=VnetServer.Service
After=rc-local.service syslog.target network.target remote-fs.target nss-lookup.target
[Service]
Type=simple
ExecStart=/usr/local/vnet/server.sh
ExecStartPost=/usr/local/vnet/server.conf
Restart=always
LimitNOFILE=512000
LimitNPROC=512000
[Install]
WantedBy=multi-user.target' >/usr/lib/systemd/system/vnets.service
	cd /root
	systemctl start vnets
	systemctl status vnets
	systemctl enable vnets
	echo -e "\033[42;37mvnet服务端安装完成\033[0m" 
}
function install_vnetc(){
	yum -y install zip unzip
    mkdir /usr/local/vnet
    cd /usr/local/vnet
    wget -N --no-check-certificate "https://www.isyunyi.com/download/linux/tunnel.zip"
    unzip tunnel.zip 
    rm -f /usr/local/vnet/tunnel.zip
    rm -f /usr/local/vnet/server
    echo '#!/bin/bash
sleep 0.5
cd /usr/local/vnet
./client' >/usr/local/vnet/client.sh 
	rm -rf /usr/local/vnet/client.conf
	echo '#!/bin/bash
sleep 1.5
#在下方编写规则
' >/usr/local/vnet/client.conf
    chmod +x /usr/local/vnet/client /usr/local/vnet/client.sh /usr/local/vnet/client.conf
	echo '
[Unit]
Description=VnetClient.Service
After=rc-local.service
[Service]
Type=simple
ExecStart=/usr/local/vnet/client.sh
ExecStartPost=/usr/local/vnet/client.conf
Restart=always
LimitNOFILE=512000
LimitNPROC=512000
[Install]
WantedBy=multi-user.target' >/usr/lib/systemd/system/vnetc.service
	cd /root
	systemctl start vnetc
	systemctl enable vnetc
	systemctl status vnetc
	echo -e "\033[42;37mvnet服务端安装完成\033[0m" 
}
function install_docker(){
wget -qO- get.docker.com | bash
systemctl start docker
systemctl enable docker
systemctl status docker
sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
rm -rf /root/docker.run
wget --no-check-certificate $Github/node/$diQu/docker -O /root/docker.run
chmod +x /root/docker.run
/root/docker.run
}
function install_gost() {
	bit="amd64"
	yum install -y gzip
    rm -rf /root/gost-linux-"$bit"-"$ct_new_ver".gz
    wget --no-check-certificate https://ghproxy.net/https://github.com/ginuerzh/gost/releases/download/v$ct_new_ver/gost-linux-$bit-$ct_new_ver.gz -O /root/gost-linux-$bit-$ct_new_ver.gz
    gunzip /root/gost-linux-"$bit"-"$ct_new_ver".gz
    mv /root/gost-linux-"$bit"-"$ct_new_ver" /usr/bin/gost
    chmod -R 777 /usr/bin/gost
    wget --no-check-certificate $GostService/gost.service && chmod -R 777 gost.service && mv gost.service /usr/lib/systemd/system
	rm -rf /etc/gost/config.json
    mkdir /etc/gost && wget --no-check-certificate $Github/node/$diQu/config.json && mv config.json /etc/gost && chmod -R 777 /etc/gost
	systemctl enable gost && systemctl restart gost
	echo "------------------------------"
if test -a /usr/bin/gost -a /usr/lib/systemctl/gost.service -a /etc/gost/config.json; then
    echo "gost安装成功"
    rm -rf "$(pwd)"/gost
    rm -rf "$(pwd)"/gost.service
    rm -rf "$(pwd)"/config.json
else
    echo "gost没有安装成功，可以在Github[EasyGost]中提交issue"
    rm -rf "$(pwd)"/gost
    rm -rf "$(pwd)"/gost.service
    rm -rf "$(pwd)"/config.json
    rm -rf "$(pwd)"/gost.sh
fi
}
#nginx废弃，使用tengine
function install_nginx() {
	yum -y update
	rpm -ivh http://nginx.org/packages/centos/7/x86_64/RPMS/nginx-1.18.0-2.el7.ngx.x86_64.rpm
	mkdir -p /usr/local/nginx/
	wget $Github/mjnginx.conf -O $nginx_Conf
	#写入配置文件
	cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backup
echo "worker_processes  1;
user nobody;
events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;

    keepalive_timeout  65;

    server {
        listen       2333;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
	include /usr/local/nginx/*.conf;
}">/etc/nginx/nginx.conf
	systemctl resatrt nginx
	systemctl enable nginx
	systemctl status nginx
}
function install_tengine() {
        yum update -y
        yum install epel-release -y
        yum install gcc gcc-c++ autoconf automake -y
        yum install pcre-devel -y
        yum install openssl-devel -y
        yum install libmcrypt libmcrypt-devel mcrypt mhash -y
		yum install kernel-headers kernel-devel make -y
		rm -rf /usr/local/nginx
		cd /root
		wget http://tengine.taobao.org/download/tengine-2.3.3.tar.gz
		tar zxvf tengine-2.3.3.tar.gz
		cd /root/tengine*
		./configure --without-http_upstream_keepalive_module --with-stream --with-stream_ssl_module --with-stream_sni --add-module=modules/ngx_http_upstream_* --add-module=modules/ngx_debug_* --add-module=modules/ngx_http_slice_module --add-module=modules/ngx_http_user_agent_module --add-module=modules/ngx_http_reqstat_module --add-module=modules/ngx_http_proxy_connect_module --add-module=modules/ngx_http_footer_filter_module
        make
        make install
        wget -N -P /usr/local/nginx/ $cndownload/download/ws
		wget -N -P /usr/local/nginx/conf/ $cndownload/download/nginx.conf
		echo "[Unit]
Description=The nginx HTTP and reverse proxy server
After=syslog.target network.target remote-fs.target nss-lookup.target
 
[Service]
Type=forking
PIDFile=/usr/local/nginx/logs/nginx.pid
ExecStartPre=/usr/local/nginx/sbin/nginx -t
ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
ExecReload=/usr/local/nginx/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT $MAINPID
PrivateTmp=true
 
[Install]
WantedBy=multi-user.target" >/lib/systemd/system/nginx.service
        systemctl daemon-reload
        systemctl start nginx
        systemctl enable nginx
        echo -e "${Green}done!${Font}"
}
function install_brook() {
		wget -N -P /root $cndownload//brook-pf-mod.sh
		chmod +x /root/brook-pf-mod.sh
		/root/brook-pf-mod.sh install
		#添加DDNS监控
		yum install bind-utils -y
    cron_config=$(crontab -l | grep "brook-pf-mod.sh monitor")
    if [[ -z ${cron_config} ]]; then
		crontab -l > "/root/crontab.bak"
		sed -i "/brook-pf-mod.sh monitor/d" "/root/crontab.bak"
		echo -e "\n*/2 * * * *  /bin/bash /root/brook-pf-mod.sh monitor" >> "/root/crontab.bak"
		crontab "/root/crontab.bak"
		rm -r "/root/crontab.bak"
        echo -e "${Info} Brook 服务端运行状态监控功能 启动成功 !"
    else
		echo -e "${Error} Brook 服务端运行状态监控功能 启动失败 !" 
    fi
}
#安装XrayR-暂时废弃
function install_xrayr() {
    mkdir /usr/local/xrayr
	wget -N -P /usr/local/xrayr https://github.com/XrayR-project/XrayR/releases/download/v0.6.1/XrayR-freebsd-64.zip
	yum install unzip -y
	cd /usr/local/xrayr
	unzip XrayR-freebsd-64.zip
	rm -rf /usr/local/xrayr/XrayR-freebsd-64.zip
	echo "[Unit]
Description=XrayR Service
After=network.target nss-lookup.target
Wants=network.target

[Service]
User=root
Group=root
Type=simple
LimitAS=infinity
LimitRSS=infinity
LimitCORE=infinity
LimitNOFILE=999999
WorkingDirectory=/usr/local/xrayr/
ExecStart=/usr/local/xrayr/XrayR -config /usr/local/xrayr/config.yml
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target" >/lib/systemd/system/xrayr.service
    systemctl enable xrayr
    echo "XrayR安装完成并设置开机自启"
}
#安装XrayR-企鹅配置
function install_xrayr_pengui() {
    echo && echo -e "  节点快速对接--XrayR
  节点快速对接，支持设置DNS解锁
  安装XrayR主程序可输入任意字符跳过安装(适用于已安装重新对接)
  DNS解锁支持预设BGP.SH地址输入：sg/jp/kr/us/uk/fr/tw/hk
  pg=对接企鹅vmess,dog=对接狗子v2ray,cv=cv2-v2ray
  可以同时对接多个网站,!还没写好！
 ————————————" 
    read -erp " 是否安装XrayR主程序(回车安装,任意字符跳过):" ins_xrayr
	read -erp " 现在开始对接第一个节点(pg|dog|cv,回车默认企鹅):" node_web
	if [[ $node_web == "" ]] || [[ $node_web == "pg" ]]; then
    node_web="pengui.xyz"
	node_type="V2ray"
	node_panel="V2board"
	node_key="www_pengui_ml123"
    elif [[ $node_web == "dog" ]]; then
	node_web="www.freedog.pw"
	node_type="V2ray"
	node_panel="SSpanel"
	node_key="qingchengss"
    elif [[ $node_web == "cv" ]]; then
	node_web="cv2.xyz"
	node_type="V2ray"
	node_panel="SSpanel"
	node_key="mycheapv2ray"
    else
    echo "您输入的信息不正确，脚本将重新执行"
	install_xrayr_pengui
    fi
    read -erp " 请输入节点ID:" node_id
    read -erp " 请输入DNS解锁地址(回车跳过):" dns_nf
	read -erp " 现在开始对接第二个节点(pg|dog,回车跳过):" node2_web
	if [[ $node2_web == "dog" ]]; then
	node_web2="www.freedog.pw"
	node_type2="V2ray"
	node_panel2="SSpanel"
	node_key2="qingchengss"
	are_you_have_node2="yes"
	elif [[ $node2_web == "pg" ]]; then
    node_web2="pengui.xyz"
	node_type2="V2ray"
	node_panel2="V2board"
	node_key2="www_pengui_ml123"
	are_you_have_node2="yes"
	else
	echo "不对接第二节点,仅执行对接第一节点"
	are_you_have_node2="no"
	fi	
#是否安装XrayR主程序
if [[ $ins_xrayr == "" ]]; then
echo "安装XrayR主程序"
bash <(curl -Ls https://raw.githubusercontent.com/XrayR-project/XrayR-release/master/install.sh)
else
echo "跳过XrayR安装"
fi
#预设DNS解锁地址
	if [[ $dns_nf == "jp" ]]; then
		dns_nf="103.142.141.23"			
	elif [[ $dns_nf == "sg" ]]; then
		dns_nf="149.129.56.249"	
	elif [[ $dns_nf == "us" ]]; then
		dns_nf="49.51.178.84"
	elif [[ $dns_nf == "uk" ]]; then
		dns_nf="161.35.161.202"
	elif [[ $dns_nf == "fr" ]]; then
		dns_nf="109.238.14.142"
	elif [[ $dns_nf == "kr" ]]; then
		dns_nf="61.111.129.138"
	elif [[ $dns_nf == "hk" ]]; then
		dns_nf="47.240.40.111"
	elif [[ $dns_nf == "tw" ]]; then
		dns_nf="34.81.172.137"
	elif [[ $dns_nf == "" ]]; then
		dns_nf="down"
    fi
#判断是否开启dns解锁
if [[ $dns_nf == "down" ]]; then
node_dns_path="# ./dns.json"
node_dns_type="AsIs"
node_dns_enable="false"
else
node_dns_path="/etc/XrayR/dns.json"
node_dns_type="UseIP"
node_dns_enable="true"
echo "{
    \"servers\": [
      \"localhost\", 
      {
        \"address\": \"$dns_nf\", 
        \"port\": 53,
        \"domains\": [
          \"geosite:netflix\" 
        ]
      }
    ]
  }" >/etc/XrayR/dns.json
fi
#判断是否添加第二节点
if [[ $are_you_have_node2 == "yes" ]]; then
node2_config="  -
    PanelType: \"$node_panel2\" # Panel type: SSpanel, V2board, PMpanel, , Proxypanel
    ApiConfig:
      ApiHost: \"https://$node_web2/\"
      ApiKey: \"$node_key2\"
      NodeID: $node_id  #这是节点ID
      NodeType: $node_type2 # Node type: V2ray, Shadowsocks, Trojan, Shadowsocks-Plugin
      Timeout: 30 # Timeout for the api request
      EnableVless: false # Enable Vless for V2ray Type
      EnableXTLS: false # Enable XTLS for V2ray and Trojan
      SpeedLimit: 0 # Mbps, Local settings will replace remote settings, 0 means disable
      DeviceLimit: 0 # Local settings will replace remote settings, 0 means disable
      RuleListPath: # ./rulelist Path to local rulelist file
    ControllerConfig:
      ListenIP: 0.0.0.0 # IP address you want to listen
      SendIP: 0.0.0.0 # IP address you want to send pacakage
      UpdatePeriodic: 60 # Time to update the nodeinfo, how many sec.
      EnableDNS: $node_dns_enable # Use custom DNS config, Please ensure that you set the dns.json well
      DNSType: $node_dns_type # AsIs, UseIP, UseIPv4, UseIPv6, DNS strategy
      EnableProxyProtocol: false # Only works for WebSocket and TCP
      EnableFallback: false # Only support for Trojan and Vless
      FallBackConfigs:  # Support multiple fallbacks
        -
          SNI: # TLS SNI(Server Name Indication), Empty for any
          Path: # HTTP PATH, Empty for any
          Dest: 80 # Required, Destination of fallback, check https://xtls.github.io/config/fallback/ for details.
          ProxyProtocolVer: 0 # Send PROXY protocol version, 0 for dsable
      CertConfig:
        CertMode: dns # Option about how to get certificate: none, file, http, dns. Choose \"none\" will forcedly disable the tls config.
        CertDomain: \"node1.test.com\" # Domain to cert
        CertFile: ./cert/node1.test.com.cert # Provided if the CertMode is file
        KeyFile: ./cert/node1.test.com.key
        Provider: alidns # DNS cert provider, Get the full support list here: https://go-acme.github.io/lego/dns/
        Email: test@me.com
        DNSEnv: # DNS ENV option used by DNS provider
          ALICLOUD_ACCESS_KEY: aaa
          ALICLOUD_SECRET_KEY: bbb"
		echo "当前对接两个节点"
else
        echo "当前对接一个节点"
fi

#开始编写配置文件
    echo "Log:
  Level: none # Log level: none, error, warning, info, debug 
  AccessPath: # ./access.Log
  ErrorPath: # ./error.log
DnsConfigPath: $node_dns_path
ConnetionConfig:
  Handshake: 4 # Handshake time limit, Second
  ConnIdle: 30 # Connection idle time limit, Second
  UplinkOnly: 2 # Time limit when the connection downstream is closed, Second
  DownlinkOnly: 4 # Time limit when the connection is closed after the uplink is closed, Second
  BufferSize: 64 # The internal cache size of each connection, kB 
Nodes:
  -
    PanelType: \"$node_panel\" # Panel type: SSpanel, V2board, PMpanel, , Proxypanel
    ApiConfig:
      ApiHost: \"https://$node_web/\"
      ApiKey: \"$node_key\"
      NodeID: $node_id  #这是节点ID
      NodeType: $node_type # Node type: V2ray, Shadowsocks, Trojan, Shadowsocks-Plugin
      Timeout: 30 # Timeout for the api request
      EnableVless: false # Enable Vless for V2ray Type
      EnableXTLS: false # Enable XTLS for V2ray and Trojan
      SpeedLimit: 0 # Mbps, Local settings will replace remote settings, 0 means disable
      DeviceLimit: 0 # Local settings will replace remote settings, 0 means disable
      RuleListPath: # ./rulelist Path to local rulelist file
    ControllerConfig:
      ListenIP: 0.0.0.0 # IP address you want to listen
      SendIP: 0.0.0.0 # IP address you want to send pacakage
      UpdatePeriodic: 60 # Time to update the nodeinfo, how many sec.
      EnableDNS: $node_dns_enable # Use custom DNS config, Please ensure that you set the dns.json well
      DNSType: $node_dns_type # AsIs, UseIP, UseIPv4, UseIPv6, DNS strategy
      EnableProxyProtocol: false # Only works for WebSocket and TCP
      EnableFallback: false # Only support for Trojan and Vless
      FallBackConfigs:  # Support multiple fallbacks
        -
          SNI: # TLS SNI(Server Name Indication), Empty for any
          Path: # HTTP PATH, Empty for any
          Dest: 80 # Required, Destination of fallback, check https://xtls.github.io/config/fallback/ for details.
          ProxyProtocolVer: 0 # Send PROXY protocol version, 0 for dsable
      CertConfig:
        CertMode: dns # Option about how to get certificate: none, file, http, dns. Choose \"none\" will forcedly disable the tls config.
        CertDomain: \"node1.test.com\" # Domain to cert
        CertFile: ./cert/node1.test.com.cert # Provided if the CertMode is file
        KeyFile: ./cert/node1.test.com.key
        Provider: alidns # DNS cert provider, Get the full support list here: https://go-acme.github.io/lego/dns/
        Email: test@me.com
        DNSEnv: # DNS ENV option used by DNS provider
          ALICLOUD_ACCESS_KEY: aaa
          ALICLOUD_SECRET_KEY: bbb
$node2_config" >/etc/XrayR/config.yml
systemctl restart XrayR
systemctl status XrayR
echo "对接完成"
}
#安装cnsync
function install_cnsync() {
	wget $cndownload/cnsync -O /usr/bin/cnsync
	chmod +x /usr/bin/cnsync
	cnsync addcron
}
#安装hksync
function install_hksync() {
	wget $cndownload/hksync -O /usr/bin/hksync	
	chmod +x /usr/bin/hksync
	hksync addcron
}
#菜单选项
function menu_server() {
  echo && echo -e "  月抛/正常鸡 一键安装docker/vnet/gost
  支持一键安装并从远端下发配置-直接黑化
 ————————————
 ${Green_font_prefix} tw:${Font_color_suffix} 安装至台湾机器
 ${Green_font_prefix} tw2:${Font_color_suffix} 安装至台湾2号机
 ${Green_font_prefix} jp:${Font_color_suffix} 安装至日本机器
————————————
 ${Green_font_prefix} 3.${Font_color_suffix} 安装脚本" &&echo 
	echo -e "输入\033[32m tw\033[0m|\033[32m jp\033[0m来进行安装" 
  echo
  read -erp " 请输入国家地区代码:" diQu
	yum update -y
	install_iptables
	install_docker
	install_vnets
	install_gost
}
#cn菜单
function menu_server2() {
  echo && echo -e "  国内机器 一键安装Nginx/Brook等
  支持一键安装并从远端下发配置-直接黑化
  tengine为nginx1.7分支，该分支支持DDNS
 ————————————
 ${Green_font_prefix} 1:${Font_color_suffix} 安装Nginx负载(已废弃，使用tengine)
 ${Green_font_prefix} 2:${Font_color_suffix} 安装tengine负载支持DDNS/主动健康检查
 ${Green_font_prefix} 3:${Font_color_suffix} 安装gost隧道
 ${Green_font_prefix} 4:${Font_color_suffix} 安装vnet隧道
 ${Green_font_prefix} 5:${Font_color_suffix} 安装brook转发
 ${Green_font_prefix} 6:${Font_color_suffix} 安装cnsync同步
 ${Green_font_prefix} 7.${Font_color_suffix} 安装vnets+hksync(只需要vnet落地)
 ${Green_font_prefix} 8.${Font_color_suffix} 安装vnets+tengine+hksync(香港跳板安装)
————————————
 ${Green_font_prefix} 0.${Font_color_suffix} 安装国内四件套(中转一键部署)" &&echo 
  echo
  read -erp " 请输入对应的数字:" Num
  case "$Num" in
  1)
    install_nginx
    ;;
  2)
	yum update -y
    install_tengine
    ;;
  3)
    install_gost
    ;;
  4)
    install_vnetc
    ;;
  5)
    install_brook
    ;;
  6)
    install_cnsync
    ;;
  7)
    install_vnets
	install_hksync
	hksync all
    ;;
  8)
    install_vnets
	install_tengine
	install_hksync
	hksync all
    ;;
  0)
	yum update -y
	install_iptables
    install_cnsync
	install_brook
	install_tengine
	install_vnetc
	install_gost
	cnsync all
    ;;
  *)
    echo "请输入正确数字 [1-3]"
    ;;
  esac
}
action=$1
if [[ -n $action ]]; then
#增加一个通信检测，如果与GitHub通信失败则停止脚本
	if [[ $github_test == "success" ]]; then
		if [[ $action == "cn" ]]; then
			menu_server2			
		elif [[ $action == "pengui" ]]; then
			install_xrayr_pengui
		elif [[ $action == "cron" ]]; then
			echo -e "\033[32m 还没写 \033[0m"
		fi
	else
		echo -e "\033[31m 远端通信失败，程序中止 \033[0m"
	fi
else
	menu_server
fi
